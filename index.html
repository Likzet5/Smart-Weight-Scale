<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Strength Training Monitor</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.5.0/Recharts.min.js"></script>
  <style>
    /* Custom styles */
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    .force-gauge {
      width: 200px;
      height: 200px;
      margin: 0 auto;
      position: relative;
      border-radius: 50%;
      background: #f3f4f6;
      overflow: hidden;
    }
    .gauge-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, #3b82f6, #60a5fa);
      transition: height 0.3s ease;
    }
    .gauge-value {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      font-weight: bold;
      z-index: 2;
    }
    .gauge-unit {
      position: absolute;
      top: 65%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.875rem;
      color: #4b5563;
      z-index: 2;
    }
    .chart-container {
      height: 300px;
      width: 100%;
    }
    /* Animations */
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    .recording-dot {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #ef4444;
      margin-right: 6px;
      animation: pulse 1.5s infinite;
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen">
  <!-- App Header -->
  <header class="bg-blue-600 text-white shadow">
    <div class="container mx-auto py-4 px-6">
      <h1 class="text-3xl font-bold">Strength Training Monitor</h1>
      <p class="text-blue-100">Tindeq API Compatible</p>
    </div>
  </header>

  <!-- Main Content -->
  <main class="container mx-auto px-6 py-8">
    <!-- Web Bluetooth Compatibility Check -->
    <div id="compatibility-check" class="hidden bg-amber-100 border-l-4 border-amber-500 p-4 rounded-lg mb-8">
      <h2 class="font-bold text-lg text-amber-800">Web Bluetooth Not Supported</h2>
      <p class="text-amber-700 mt-2">
        Your browser doesn't support Web Bluetooth API which is required to connect to your training device.
        Please use Chrome, Edge, or Opera on desktop, or Chrome for Android.
      </p>
    </div>

    <!-- Connection Status -->
    <div class="bg-white rounded-xl shadow p-6 mb-8">
      <div class="flex flex-wrap items-center justify-between">
        <div>
          <h2 class="text-xl font-semibold mb-2">Device Connection</h2>
          <p id="connection-status" class="text-red-600 font-medium">Not Connected</p>
          <p id="device-name" class="text-gray-500 text-sm mt-1 hidden"></p>
        </div>
        <div class="flex space-x-3 mt-4 sm:mt-0">
          <button id="connect-button" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition">
            Connect Device
          </button>
          <button id="disconnect-button" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition" disabled>
            Disconnect
          </button>
          <button id="tare-button" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg transition" disabled>
            Tare
          </button>
        </div>
      </div>
      <p id="error-message" class="text-red-500 mt-2 hidden"></p>
    </div>

    <!-- Force Measurements -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
      <!-- Current Force Gauge -->
      <div class="bg-white rounded-xl shadow p-6">
        <h3 class="text-lg font-medium text-center mb-4">Current Force</h3>
        <div class="force-gauge">
          <div id="current-force-fill" class="gauge-fill" style="height: 0%"></div>
          <div id="current-force" class="gauge-value">0.0</div>
          <div id="force-unit" class="gauge-unit">kg</div>
        </div>
      </div>

      <!-- Peak Force -->
      <div class="bg-white rounded-xl shadow p-6">
        <h3 class="text-lg font-medium text-center mb-4">Peak Force</h3>
        <div class="force-gauge">
          <div id="peak-force-fill" class="gauge-fill" style="height: 0%"></div>
          <div id="peak-force" class="gauge-value">0.0</div>
          <div class="gauge-unit">kg</div>
        </div>
      </div>

      <!-- Recording Status -->
      <div class="bg-white rounded-xl shadow p-6">
        <h3 class="text-lg font-medium text-center mb-4">Recording Status</h3>
        <div class="flex flex-col items-center justify-center h-3/4">
          <div id="recording-indicator" class="hidden">
            <span class="recording-dot"></span>
            <span class="font-medium text-red-600">RECORDING</span>
          </div>
          <div class="text-4xl font-bold mt-2" id="recording-time">0.0</div>
          <div class="text-sm text-gray-500 mt-1">seconds</div>
          <div class="flex space-x-3 mt-6">
            <button id="start-recording" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg transition" disabled>
              Start
            </button>
            <button id="stop-recording" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded-lg transition" disabled>
              Stop
            </button>
            <button id="reset-data" class="px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg transition" disabled>
              Reset
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Force Graph -->
    <div class="bg-white rounded-xl shadow p-6 mb-8">
      <h3 class="text-lg font-medium mb-4">Force Over Time</h3>
      <div id="chart-container" class="chart-container">
        <!-- Chart will be rendered here -->
      </div>
    </div>

    <!-- Settings -->
    <div class="bg-white rounded-xl shadow p-6 mb-8">
      <h3 class="text-lg font-medium mb-4">Settings</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Exercise Type
          </label>
          <select id="exercise-type" class="w-full p-2 border rounded-md">
            <option value="deadlift">Deadlift</option>
            <option value="bench">Bench Press</option>
            <option value="squat">Squat</option>
            <option value="overhead">Overhead Press</option>
            <option value="row">Row</option>
            <option value="custom">Custom</option>
          </select>
        </div>

        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Weight Unit
          </label>
          <select id="weight-unit" class="w-full p-2 border rounded-md">
            <option value="kg">Kilograms (kg)</option>
            <option value="lbs">Pounds (lbs)</option>
            <option value="N">Newtons (N)</option>
          </select>
        </div>

        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Max Force Display Range
          </label>
          <input type="number" id="max-force" class="w-full p-2 border rounded-md" value="150" min="10" max="500">
        </div>

        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Record Duration (seconds)
          </label>
          <input type="number" id="record-duration" class="w-full p-2 border rounded-md" value="10" min="1" max="60">
        </div>

        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Target Force (kg)
          </label>
          <input type="number" id="target-force" class="w-full p-2 border rounded-md" value="100" min="0">
        </div>

        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Show Target Line
          </label>
          <div class="flex items-center mt-3">
            <input type="checkbox" id="show-target" class="h-4 w-4 text-blue-600">
            <label for="show-target" class="ml-2 text-gray-700">Display target force on graph</label>
          </div>
        </div>
      </div>
    </div>

    <!-- Demo Mode -->
    <div class="bg-white rounded-xl shadow p-6 mb-8">
      <h3 class="text-lg font-medium mb-4">Demo Mode</h3>
      <p class="text-gray-600 mb-4">No device? You can try the app with simulated data.</p>
      <button id="demo-button" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg transition">
        Start Demo Mode
      </button>
    </div>
  </main>

  <!-- Footer -->
  <footer class="bg-gray-800 text-white py-6">
    <div class="container mx-auto px-6">
      <p>Â© 2025 Strength Training Monitor. All rights reserved.</p>
      <p class="text-gray-400 text-sm mt-2">Uses Web Bluetooth to connect directly to your device. No data is sent to any server.</p>
    </div>
  </footer>

  <!-- Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.5.0/Recharts.min.js"></script>
  <script>
    // Check if Web Bluetooth is supported
    if (!navigator.bluetooth) {
      document.getElementById('compatibility-check').classList.remove('hidden');
    }
  </script>
  <script src="tindeq-api.js"></script>
  <script>
    // DOM Elements
    const connectBtn = document.getElementById('connect-button');
    const disconnectBtn = document.getElementById('disconnect-button');
    const tareBtn = document.getElementById('tare-button');
    const startRecordingBtn = document.getElementById('start-recording');
    const stopRecordingBtn = document.getElementById('stop-recording');
    const resetDataBtn = document.getElementById('reset-data');
    const demoBtn = document.getElementById('demo-button');
    const connectionStatus = document.getElementById('connection-status');
    const deviceName = document.getElementById('device-name');
    const errorMessage = document.getElementById('error-message');
    const currentForceEl = document.getElementById('current-force');
    const currentForceFill = document.getElementById('current-force-fill');
    const peakForceEl = document.getElementById('peak-force');
    const peakForceFill = document.getElementById('peak-force-fill');
    const recordingTime = document.getElementById('recording-time');
    const recordingIndicator = document.getElementById('recording-indicator');

    // Settings elements
    const exerciseType = document.getElementById('exercise-type');
    const weightUnit = document.getElementById('weight-unit');
    const maxForce = document.getElementById('max-force');
    const recordDuration = document.getElementById('record-duration');
    const targetForce = document.getElementById('target-force');
    const showTarget = document.getElementById('show-target');
    const forceUnit = document.getElementById('force-unit');

    // State variables
    let currentForce = 0;
    let peakForce = 0;
    let forceHistory = [];
    let isRecording = false;
    let isDemo = false;
    let recordingInterval = null;
    let recordingStartTime = 0;
    let demoInterval = null;
    let chart = null;

    // Initialize Tindeq device
    const tindeq = new TindeqDevice();

    // Button event listeners
    connectBtn.addEventListener('click', connectDevice);
    disconnectBtn.addEventListener('click', disconnectDevice);
    tareBtn.addEventListener('click', tareDevice);
    startRecordingBtn.addEventListener('click', startRecording);
    stopRecordingBtn.addEventListener('click', stopRecording);
    resetDataBtn.addEventListener('click', resetData);
    demoBtn.addEventListener('click', toggleDemoMode);

    // Settings event listeners
    weightUnit.addEventListener('change', updateWeightUnit);
    maxForce.addEventListener('change', updateUI);
    showTarget.addEventListener('change', updateChart);

    // Connect to Tindeq device
    async function connectDevice() {
      try {
        errorMessage.classList.add('hidden');
        await tindeq.connect();
      } catch (error) {
        showError("Failed to connect: " + error.message);
      }
    }

    // Disconnect from device
    async function disconnectDevice() {
      if (isRecording) {
        await stopRecording();
      }
      await tindeq.disconnect();
    }

    // Tare the device
    async function tareDevice() {
      try {
        errorMessage.classList.add('hidden');
        await tindeq.tare();
      } catch (error) {
        showError("Failed to tare: " + error.message);
      }
    }

    // Start recording session
    async function startRecording() {
      try {
        // Reset data
        peakForce = 0;
        forceHistory = [];
        recordingStartTime = Date.now();
        isRecording = true;
        
        // Update UI
        recordingIndicator.classList.remove('hidden');
        updateButtonStates();
        
        // Start recording on device (if not in demo mode)
        if (!isDemo) {
          await tindeq.startMeasurement();
        }
        
        // Start timer
        recordingInterval = setInterval(() => {
          const elapsed = (Date.now() - recordingStartTime) / 1000;
          recordingTime.textContent = elapsed.toFixed(1);
          
          // Generate demo data if in demo mode
          if (isDemo) {
            generateDemoData(elapsed);
          }
          
          // Stop recording after duration
          if (elapsed >= parseFloat(recordDuration.value)) {
            stopRecording();
          }
        }, 100);
      } catch (error) {
        showError("Failed to start recording: " + error.message);
      }
    }

    // Stop recording session
    async function stopRecording() {
      isRecording = false;
      recordingIndicator.classList.add('hidden');
      
      // Clear interval
      if (recordingInterval) {
        clearInterval(recordingInterval);
        recordingInterval = null;
      }
      
      // Stop device if not in demo mode
      if (!isDemo && tindeq.isConnected()) {
        try {
          await tindeq.stopMeasurement();
        } catch (error) {
          showError("Failed to stop recording: " + error.message);
        }
      }
      
      updateButtonStates();
    }

    // Reset all data
    function resetData() {
      currentForce = 0;
      peakForce = 0;
      forceHistory = [];
      recordingTime.textContent = "0.0";
      updateUI();
      updateChart();
    }

    // Toggle demo mode
    function toggleDemoMode() {
      if (isDemo) {
        // Stop demo mode
        isDemo = false;
        demoBtn.textContent = "Start Demo Mode";
        demoBtn.classList.remove("bg-red-600", "hover:bg-red-700");
        demoBtn.classList.add("bg-purple-600", "hover:bg-purple-700");
        
        if (demoInterval) {
          clearInterval(demoInterval);
          demoInterval = null;
        }
        
        // Reset data
        resetData();
      } else {
        // Start demo mode
        isDemo = true;
        demoBtn.textContent = "Stop Demo Mode";
        demoBtn.classList.remove("bg-purple-600", "hover:bg-purple-700");
        demoBtn.classList.add("bg-red-600", "hover:bg-red-700");
        
        // Enable controls
        startRecordingBtn.disabled = false;
        resetDataBtn.disabled = false;
        
        // Update status
        connectionStatus.textContent = "Demo Mode";
        connectionStatus.classList.remove("text-red-600");
        connectionStatus.classList.add("text-green-600");
        
        // Generate data periodically if not recording
        if (!isRecording) {
          demoInterval = setInterval(() => {
            updateForce(Math.random() * 20);
          }, 200);
        }
      }
      
      updateButtonStates();
    }

    // Generate demo data for recording
    function generateDemoData(timeSeconds) {
      // Create a bell curve with noise
      const maxTime = parseFloat(recordDuration.value);
      const peakTime = maxTime / 2;
      const maxTargetForce = parseFloat(targetForce.value);
      
      // Bell curve formula
      const bellCurve = Math.exp(-Math.pow((timeSeconds - peakTime) / (maxTime / 5), 2));
      const noise = (Math.random() - 0.5) * (maxTargetForce * 0.1);
      
      // Calculate force with some random noise
      const force = maxTargetForce * bellCurve + noise;
      
      // Update display and history
      updateForce(force);
      forceHistory.push({ time: timeSeconds, force });
      updateChart();
    }

    // Update force displays
    function updateForce(force) {
      currentForce = force;
      currentForceEl.textContent = force.toFixed(1);
      
      // Update gauge fill
      const maxF = parseFloat(maxForce.value);
      const fillPercent = Math.min(100, (force / maxF) * 100);
      currentForceFill.style.height = `${fillPercent}%`;
      
      // Update peak force if higher
      if (force > peakForce) {
        peakForce = force;
        peakForceEl.textContent = force.toFixed(1);
        peakForceFill.style.height = `${Math.min(100, (force / maxF) * 100)}%`;
      }
    }

    // Update weight unit
    function updateWeightUnit() {
      const unit = weightUnit.value;
      forceUnit.textContent = unit;
      
      // Update chart if needed
      updateChart();
    }

    // Show error message
    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.classList.remove('hidden');
    }

    // Update button states based on current state
    function updateButtonStates() {
      const connected = tindeq.isConnected() || isDemo;
      
      connectBtn.disabled = connected;
      disconnectBtn.disabled = !tindeq.isConnected();
      tareBtn.disabled = !tindeq.isConnected();
      startRecordingBtn.disabled = !connected || isRecording;
      stopRecordingBtn.disabled = !isRecording;
      resetDataBtn.disabled = !connected;
    }

    // Update the force chart
    function updateChart() {
      const chartContainer = document.getElementById('chart-container');
      
      // If Recharts is not loaded, use a simple canvas-based chart
      if (!window.Recharts) {
        // Clear container
        chartContainer.innerHTML = '';
        
        // Create canvas element if it doesn't exist
        let canvas = chartContainer.querySelector('canvas');
        if (!canvas) {
          canvas = document.createElement('canvas');
          canvas.width = chartContainer.clientWidth;
          canvas.height = chartContainer.clientHeight;
          chartContainer.appendChild(canvas);
        }
        
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // If no data, show empty state
        if (forceHistory.length === 0) {
          ctx.fillStyle = '#9CA3AF';
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data to display. Start recording to see your force graph.', width / 2, height / 2);
          return;
        }
        
        // Draw chart
        const padding = { top: 20, right: 20, bottom: 30, left: 40 };
        const chartWidth = width - padding.left - padding.right;
        const chartHeight = height - padding.top - padding.bottom;
        
        // Find max values
        const maxTime = Math.max(...forceHistory.map(d => d.time), parseFloat(recordDuration.value));
        const maxValue = Math.max(...forceHistory.map(d => d.force), parseFloat(targetForce.value)) * 1.1;
        
        // Draw axes
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        
        // X-axis
        ctx.beginPath();
        ctx.moveTo(padding.left, height - padding.bottom);
        ctx.lineTo(width - padding.right, height - padding.bottom);
        ctx.stroke();
        
        // Y-axis
        ctx.beginPath();
        ctx.moveTo(padding.left, padding.top);
        ctx.lineTo(padding.left, height - padding.bottom);
        ctx.stroke();
        
        // X-axis labels
        ctx.fillStyle = '#4B5563';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        for (let i = 0; i <= maxTime; i += maxTime / 5) {
          const x = padding.left + (i / maxTime) * chartWidth;
          ctx.fillText(i.toFixed(1) + 's', x, height - padding.bottom + 15);
        }
        
        // Y-axis labels
        ctx.textAlign = 'right';
        const yLabelCount = 5;
        for (let i = 0; i <= yLabelCount; i++) {
          const value = (i / yLabelCount) * maxValue;
          const y = height - padding.bottom - (i / yLabelCount) * chartHeight;
          ctx.fillText(value.toFixed(0) + weightUnit.value, padding.left - 5, y + 3);
        }
        
        // Draw target line if enabled
        if (showTarget.checked) {
          const target = parseFloat(targetForce.value);
          const targetY = height - padding.bottom - (target / maxValue) * chartHeight;
          
          ctx.beginPath();
          ctx.setLineDash([5, 5]);
          ctx.strokeStyle = '#EF4444';
          ctx.lineWidth = 2;
          ctx.moveTo(padding.left, targetY);
          ctx.lineTo(width - padding.right, targetY);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        // Draw data line
        if (forceHistory.length > 0) {
          ctx.beginPath();
          ctx.strokeStyle = '#3B82F6';
          ctx.lineWidth = 2;
          ctx.lineJoin = 'round';
          
          forceHistory.forEach((point, i) => {
            const x = padding.left + (point.time / maxTime) * chartWidth;
            const y = height - padding.bottom - (point.force / maxValue) * chartHeight;
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          });
          
          ctx.stroke();
          
          // Draw points
          forceHistory.forEach(point => {
            const x = padding.left + (point.time / maxTime) * chartWidth;
            const y = height - padding.bottom - (point.force / maxValue) * chartHeight;
            
            ctx.beginPath();
            ctx.fillStyle = '#3B82F6';
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
          });
        }
        
        return;
      }
      
      // Use Recharts for a more sophisticated chart if available
      const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ReferenceLine } = Recharts;
      
      // Prepare data - ensure time values are fixed to 1 decimal place
      const chartData = forceHistory.map(point => ({
        time: parseFloat(point.time.toFixed(1)),
        force: point.force
      }));
      
      // Determine max domain values
      const maxTime = Math.max(...chartData.map(d => d.time), parseFloat(recordDuration.value));
      
      // Create Recharts component
      const chart = React.createElement(
        LineChart, 
        { 
          width: chartContainer.clientWidth,
          height: chartContainer.clientHeight,
          data: chartData,
          margin: { top: 5, right: 30, left: 20, bottom: 5 }
        },
        React.createElement(CartesianGrid, { strokeDasharray: "3 3" }),
        React.createElement(XAxis, { 
          dataKey: "time",
          type: "number",
          domain: [0, maxTime],
          label: { value: 'Time (seconds)', position: 'insideBottomRight', offset: -5 }
        }),
        React.createElement(YAxis, { 
          label: { value: `Force (${weightUnit.value})`, angle: -90, position: 'insideLeft' }
        }),
        React.createElement(Tooltip, { 
          formatter: (value) => [`${value.toFixed(1)} ${weightUnit.value}`, 'Force']
        }),
        React.createElement(Legend),
        React.createElement(
          Line, 
          { 
            type: "monotone", 
            dataKey: "force", 
            stroke: "#3B82F6", 
            dot: true,
            activeDot: { r: 8 }
          }
        ),
        showTarget.checked ? React.createElement(
          ReferenceLine,
          {
            y: parseFloat(targetForce.value),
            stroke: "red",
            strokeDasharray: "3 3",
            label: "Target"
          }
        ) : null
      );
      
      // Render chart
      ReactDOM.render(chart, chartContainer);
    }

    // Update UI based on current state
    function updateUI() {
      // Update force displays
      currentForceEl.textContent = currentForce.toFixed(1);
      peakForceEl.textContent = peakForce.toFixed(1);
      
      // Update gauge fills
      const maxF = parseFloat(maxForce.value);
      currentForceFill.style.height = `${Math.min(100, (currentForce / maxF) * 100)}%`;
      peakForceFill.style.height = `${Math.min(100, (peakForce / maxF) * 100)}%`;
      
      // Update button states
      updateButtonStates();
      
      // Update chart
      updateChart();
    }

    // Tindeq event handlers
    tindeq.onConnectionChange = (connected, deviceName) => {
      if (connected) {
        connectionStatus.textContent = "Connected";
        connectionStatus.classList.remove("text-red-600");
        connectionStatus.classList.add("text-green-600");
        
        if (deviceName) {
          document.getElementById('device-name').textContent = deviceName;
          document.getElementById('device-name').classList.remove("hidden");
        }
      } else {
        connectionStatus.textContent = "Not Connected";
        connectionStatus.classList.remove("text-green-600");
        connectionStatus.classList.add("text-red-600");
        document.getElementById('device-name').classList.add("hidden");
        
        // Stop recording if active
        if (isRecording) {
          stopRecording();
        }
      }
      
      updateButtonStates();
    };

    tindeq.onWeightUpdate = (weight, timestamp) => {
      updateForce(weight);
      
      // Add to history if recording
      if (isRecording) {
        const timeSeconds = (Date.now() - recordingStartTime) / 1000;
        forceHistory.push({ time: timeSeconds, force: weight });
        updateChart();
      }
    };

    tindeq.onError = (error) => {
      showError(error.message);
    };

    // Initial UI update
    updateUI();
  </script>
</body>
</html>
